import logging
from datetime import datetime
from typing import Dict, Any, List, Optional
from io import BytesIO

# Configure logging
logger = logging.getLogger(__name__)

# Lazy import WeasyPrint (requires system libraries)
_WEASYPRINT_AVAILABLE = False
try:
    from weasyprint import HTML, CSS
    from weasyprint.text.fonts import FontConfiguration
    _WEASYPRINT_AVAILABLE = True
    logger.info("WeasyPrint loaded successfully - PDF generation available")
except (ImportError, OSError) as e:
    logger.warning(f"WeasyPrint not available: {str(e)}")
    logger.warning("PDF generation will be disabled. HTML output still available.")
    logger.warning("To enable PDF: brew install pango cairo gdk-pixbuf libffi (macOS)")

# Medical document disclaimer
MEDICAL_DISCLAIMER = """
<div class="disclaimer">
    <p><strong>⚠️ IMPORTANT MEDICAL DISCLAIMER</strong></p>
    <p>This document is generated by an AI assistant for educational and informational purposes only. 
    It should NOT be used as a substitute for professional medical advice, diagnosis, or treatment. 
    Always seek the advice of your physician or other qualified health provider with any questions 
    you may have regarding a medical condition. Never disregard professional medical advice or 
    delay in seeking it because of information provided in this document.</p>
    <p>If you are experiencing a medical emergency, call emergency services immediately.</p>
</div>
"""


def create_artifact_structure(
    artifact_type: str,
    title: str,
    sections: List[Dict[str, Any]],
    metadata: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """
    Create a structured artifact object.
    
    Args:
        artifact_type: Type of artifact (lab_explanation, imaging_analysis, medical_summary)
        title: Document title
        sections: List of sections with heading, content, and optional data
        metadata: Optional metadata dict
        
    Returns:
        Structured artifact dict
    """
    return {
        "type": artifact_type,
        "title": title,
        "content": {
            "sections": sections,
            "metadata": metadata or {
                "generated_at": datetime.utcnow().isoformat(),
                "generator": "HUE AI Multi Disease Detector",
                "version": "1.0"
            }
        },
        "pdf_ready": True,
        "created_at": datetime.utcnow().isoformat()
    }


def generate_html_content(artifact: Dict[str, Any]) -> str:
    """
    Generate HTML content from artifact structure.
    
    Args:
        artifact: Artifact dict with type, title, and content
        
    Returns:
        HTML string
    """
    title = artifact.get("title", "Medical Document")
    artifact_type = artifact.get("type", "document")
    content = artifact.get("content", {})
    sections = content.get("sections", [])
    metadata = content.get("metadata", {})
    
    # Map artifact types to readable names
    type_names = {
        "lab_explanation": "Laboratory Test Explanation",
        "imaging_analysis": "Imaging Study Analysis",
        "medical_summary": "Medical Summary"
    }
    
    type_display = type_names.get(artifact_type, "Medical Document")
    
    # Generate sections HTML
    sections_html = ""
    for section in sections:
        heading = section.get("heading", "")
        section_content = section.get("content", "")
        data = section.get("data", {})
        
        sections_html += f'<div class="section">'
        
        if heading:
            sections_html += f'<h2>{heading}</h2>'
        
        # Convert content (handle line breaks)
        formatted_content = section_content.replace("\n", "<br>")
        sections_html += f'<div class="section-content">{formatted_content}</div>'
        
        # Add data table if present
        if data:
            sections_html += '<div class="data-table"><table>'
            for key, value in data.items():
                sections_html += f'<tr><td><strong>{key}</strong></td><td>{value}</td></tr>'
            sections_html += '</table></div>'
        
        sections_html += '</div>'
    
    # Generate metadata HTML
    generated_at = metadata.get("generated_at", datetime.utcnow().isoformat())
    generator = metadata.get("generator", "HUE AI")
    
    # Build complete HTML
    html = f"""
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>{title}</title>
    </head>
    <body>
        <div class="document">
            <div class="header">
                <div class="logo">HUE AI</div>
                <div class="doc-type">{type_display}</div>
            </div>
            
            <h1 class="title">{title}</h1>
            
            <div class="metadata">
                <p><strong>Generated:</strong> {generated_at}</p>
                <p><strong>Source:</strong> {generator}</p>
            </div>
            
            <div class="content">
                {sections_html}
            </div>
            
            {MEDICAL_DISCLAIMER}
            
            <div class="footer">
                <p>Document generated by HUE AI Multi Disease Detector</p>
                <p>For questions or concerns, consult with a qualified healthcare professional</p>
            </div>
        </div>
    </body>
    </html>
    """
    
    return html


def get_document_css() -> str:
    """
    Get CSS styling for medical documents.
    
    Returns:
        CSS string
    """
    return """
    @page {
        size: A4;
        margin: 2cm;
    }
    
    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        line-height: 1.6;
        color: #333;
        margin: 0;
        padding: 0;
    }
    
    .document {
        max-width: 800px;
        margin: 0 auto;
    }
    
    .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 3px solid #2563eb;
        padding-bottom: 10px;
        margin-bottom: 20px;
    }
    
    .logo {
        font-size: 24px;
        font-weight: bold;
        color: #2563eb;
    }
    
    .doc-type {
        font-size: 14px;
        color: #666;
        text-transform: uppercase;
        letter-spacing: 1px;
    }
    
    .title {
        font-size: 28px;
        color: #1e40af;
        margin: 20px 0;
        font-weight: 600;
    }
    
    .metadata {
        background-color: #f3f4f6;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 30px;
        font-size: 14px;
    }
    
    .metadata p {
        margin: 5px 0;
    }
    
    .content {
        margin: 30px 0;
    }
    
    .section {
        margin-bottom: 30px;
        page-break-inside: avoid;
    }
    
    .section h2 {
        font-size: 20px;
        color: #1e40af;
        margin-bottom: 15px;
        border-bottom: 2px solid #dbeafe;
        padding-bottom: 5px;
    }
    
    .section-content {
        font-size: 15px;
        line-height: 1.8;
        margin-bottom: 15px;
    }
    
    .data-table {
        margin: 20px 0;
    }
    
    .data-table table {
        width: 100%;
        border-collapse: collapse;
        background-color: #fff;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    
    .data-table td {
        padding: 12px;
        border: 1px solid #e5e7eb;
    }
    
    .data-table tr:nth-child(even) {
        background-color: #f9fafb;
    }
    
    .disclaimer {
        background-color: #fef2f2;
        border-left: 4px solid #dc2626;
        padding: 20px;
        margin: 30px 0;
        page-break-inside: avoid;
    }
    
    .disclaimer p {
        margin: 10px 0;
        font-size: 13px;
        line-height: 1.6;
    }
    
    .disclaimer strong {
        color: #dc2626;
        font-size: 14px;
    }
    
    .footer {
        margin-top: 40px;
        padding-top: 20px;
        border-top: 2px solid #e5e7eb;
        text-align: center;
        font-size: 12px;
        color: #666;
    }
    
    .footer p {
        margin: 5px 0;
    }
    """


def artifact_to_pdf(artifact: Dict[str, Any]) -> bytes:
    """
    Convert an artifact to PDF bytes.
    
    Args:
        artifact: Artifact dict with structure
        
    Returns:
        PDF bytes
        
    Raises:
        Exception: If PDF generation fails or WeasyPrint not available
    """
    if not _WEASYPRINT_AVAILABLE:
        raise RuntimeError(
            "PDF generation not available. WeasyPrint system libraries not installed. "
            "Install with: brew install pango cairo gdk-pixbuf libffi (macOS) "
            "or use HTML output instead."
        )
    
    try:
        logger.info(f"Converting artifact to PDF: {artifact.get('type', 'unknown')}")
        
        # Generate HTML content
        html_content = generate_html_content(artifact)
        
        # Get CSS styling
        css_content = get_document_css()
        
        # Configure fonts
        font_config = FontConfiguration()
        
        # Create PDF
        html_obj = HTML(string=html_content)
        css_obj = CSS(string=css_content, font_config=font_config)
        
        # Render to PDF bytes
        pdf_bytes = html_obj.write_pdf(stylesheets=[css_obj], font_config=font_config)
        
        logger.info("PDF generation successful")
        return pdf_bytes
        
    except Exception as e:
        logger.error(f"Error generating PDF: {str(e)}")
        raise


def artifact_to_html(artifact: Dict[str, Any]) -> str:
    """
    Convert an artifact to HTML string for display.
    
    Args:
        artifact: Artifact dict with structure
        
    Returns:
        HTML string with inline CSS
    """
    html_content = generate_html_content(artifact)
    css_content = get_document_css()
    
    # Combine HTML with inline CSS
    full_html = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <style>
        {css_content}
        </style>
    </head>
    {html_content[html_content.find('<body>'):]}
    """
    
    return full_html


def is_pdf_available() -> bool:
    """
    Check if PDF generation is available.
    
    Returns:
        True if WeasyPrint is loaded, False otherwise
    """
    return _WEASYPRINT_AVAILABLE

